package com.technegames.mymediaplayer;

import java.io.File;
import java.io.FileDescriptor;
import java.io.IOException;
import java.io.PrintStream;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.res.AssetFileDescriptor;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnCompletionListener;
import android.media.audiofx.PresetReverb;
import android.os.BatteryManager;
import android.os.Environment;
import android.os.PowerManager;
import android.text.format.Time;
import android.widget.SeekBar;

modes {
	high <: full;
	low <: high;
}

/*
 * TODO: battery interface
 * {5} syntax, assign counter
 * calibrator stack, going into functions / pop stack on update
 */

public class Music implements OnCompletionListener{
	MediaPlayer mediaPlayer;
	boolean isPrepared = false;
	
	public Music(AssetFileDescriptor assetDescriptor){
		mediaPlayer = new MediaPlayer();
		try{
			mediaPlayer.setDataSource(assetDescriptor.getFileDescriptor(), assetDescriptor.getStartOffset(), assetDescriptor.getLength());
			mediaPlayer.prepare();
			isPrepared = true;
			mediaPlayer.setOnCompletionListener(this);
		} catch(Exception ex){
			throw new RuntimeException("Couldn't load music, uh oh!");
		}
	}
	
	public Music(FileDescriptor fileDescriptor){
		mediaPlayer = new MediaPlayer();
		try{
			mediaPlayer.setDataSource(fileDescriptor);
			mediaPlayer.prepare();
			isPrepared = true;
			mediaPlayer.setOnCompletionListener(this);
		} catch(Exception ex){
			throw new RuntimeException("Couldn't load music, uh oh!");
		}
	}
	
	public void onCompletion(MediaPlayer mediaPlayer) {
		synchronized(this){
			isPrepared = false;
		}
	}
	
	/*
	public class Record extends Thread {
		public volatile boolean running = true;
		public volatile Calibrator calibrator = null;

		@Override
		public void run() {
			PrintStream ps = null;
			try {
				File file = new File(Environment.getExternalStoragePublicDirectory(
						Environment.DIRECTORY_DOWNLOADS), "MyMediaPlayerEco.csv");
				if (!file.exists()) file.createNewFile();
				ps = new PrintStream(file);
				long start = System.currentTimeMillis();
				ps.println("battery, " + "seconds, " + "current position, " + "total duration, "
						+ "current mode");
				while (running) {
		            IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
		            Intent batteryStatus = context.registerReceiver(null, ifilter);
					ps.println(batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) + ", "
							+ (System.currentTimeMillis() - start)/1000 + ", "
							+ mediaPlayer.getCurrentPosition() + ", "
							+ mediaPlayer.getDuration() + ", "
							+ calibrator.getMode());
					sleep(1000);
				}
				ps.close();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	*/
	
	/*
	public interface Calibrator {
		int getMode();
		public Object calibrate(Object input);
	}
	*/
	
	// static stack class push on each sustainable block, pop on every access
	// alias analysis
	// tricky: conservativeness, more pop than needed
	public class PositionWrapper {
		public int current;
		public double test;
	}
	
	public class SubWrapper extends PositionWrapper {
	}
	
	public class PositionGetter {
		public void getPosition(PositionWrapper wrapper, MediaPlayer mediaPlayer) {
			wrapper.current = mediaPlayer.getCurrentPosition();
			wrapper.test = mediaPlayer.getCurrentPosition();
		}
	}
	
	public class Progress extends Thread {
		public volatile boolean playing = true;
		//public int current = 0;
		SubWrapper wrapper = new SubWrapper();
		private int duration = 0;
		public void run() {
			
			//*
			 	mcase<int> sleepTime = mcase<int> { low: 100; high: 10; full: 1 };
			 	mcase<float> effectLevel = mcase<float> { low: (float)0.1F; high: (float)0.5F; full: (float)1F };
		 		mcase<int> wakeLock = mcase<int> {
		 			low : PowerManager.PARTIAL_WAKE_LOCK;
		 			high: PowerManager.SCREEN_DIM_WAKE_LOCK;
		 			full: PowerManager.FULL_WAKE_LOCK
		 		};
		 	
				duration = mediaPlayer.getDuration();

				// referenced local variables are transformed into final array of size 1
				//int duration;
				//duration = 10;
				
				PositionGetter getter = new PositionGetter();
				
			 	sustainable {
					while (playing) {
						getter.getPosition(wrapper, mediaPlayer);
						//wrapper.current = mediaPlayer.getCurrentPosition();
						seek.setProgress(seek.getMax() * wrapper.current / duration);
						mediaPlayer.setAuxEffectSendLevel(effectLevel + 0F);
						mediaPlayer.setWakeMode(context, wakeLock + 0);
						try {
							sleep(sleepTime + 0);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
				}
				bsupply(5)
				demand(duration) -> (duration - wrapper.current);
				//FIXME: problem with Progress.this.duration, special field targets
			/*/

		 	int[] sleepTime = new int[] { 100, 10, 1 };
		 	float[] effectLevel = new float[] { 0.1F, 0.5F, 1F };
		 	int[] wakeLock = new int[] {
		 			PowerManager.PARTIAL_WAKE_LOCK,
		 			PowerManager.SCREEN_DIM_WAKE_LOCK,
		 			PowerManager.FULL_WAKE_LOCK
		 	};
		 	
			duration = mediaPlayer.getDuration();
			
			Calibrator $calibrator = new Calibrator() {		
				private volatile int mode = 2;
                private double budget = 10;
                IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
                Intent batteryStatus = context.registerReceiver(null, ifilter);
				private int bInitial = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
                public int getMode() {
                        return mode;
                }
				public Object calibrate(Object input) {
						IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
						Intent batteryStatus = context.registerReceiver(null, ifilter);
						int bLeft = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
                        double sratio = (budget - (bInitial - bLeft))/budget;
                        double dratio = (double)(duration - current)/(duration);
                        if (sratio > dratio * 1.01 && mode < 2) ++mode;
                        else if (dratio > sratio * 1.01 && mode > 0) --mode;
                        //System.out.println("bInitial: " + bInitial);
                        //System.out.println("bLeft: " + bLeft);
                        //System.out.println("mode: " + mode);
                        return input;
                }
            };
            
            Record record = new Record();
            record.calibrator = $calibrator;
            record.start();
            
			{
				while (playing) {
					$calibrator.calibrate(current = mediaPlayer.getCurrentPosition());
					seek.setProgress(seek.getMax() * current / duration);
					mediaPlayer.setAuxEffectSendLevel(effectLevel[$calibrator.getMode()]);
					mediaPlayer.setWakeMode(context, wakeLock[$calibrator.getMode()]);
					try {
						sleep(sleepTime[$calibrator.getMode()]);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
			
			record.running = false;
			try {
				record.join();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			//*/
		}
	}
	
	SeekBar seek = null;
	Context context = null;
	Progress progress = null;

	public void play(SeekBar seek, Context context) {
		this.seek = seek;
		this.context = context;
		if(mediaPlayer.isPlaying()){
			return;
		}
		try{
			synchronized(this){
				if(!isPrepared){
					mediaPlayer.prepare();
				 	PresetReverb effect = new PresetReverb(0, 0);
				 	effect.setPreset(PresetReverb.PRESET_LARGEHALL);
				 	effect.setEnabled(true);
				 	mediaPlayer.attachAuxEffect(effect.getId());
				}
				mediaPlayer.start();
				progress = new Progress();
				progress.start();
			}
		} catch(IllegalStateException ex){
			ex.printStackTrace();
		} catch(IOException ex){
			ex.printStackTrace();
		}
	}

	public void stop() {
		progress.playing = false;
		try {
			progress.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		seek.setProgress(0);
		mediaPlayer.stop();
		synchronized(this){
			isPrepared = false;
		}
	}
	
	public void switchTracks(){
		mediaPlayer.seekTo(0);
		mediaPlayer.pause();
	}
	
	public void pause() {
		progress.playing = false;
		mediaPlayer.pause();
	}

	public boolean isPlaying() {
		return mediaPlayer.isPlaying();
	}
	
	public boolean isLooping() {
		return mediaPlayer.isLooping();
	}
	
	public void setLooping(boolean isLooping) {
		mediaPlayer.setLooping(isLooping);
	}

	public void setVolume(float volumeLeft, float volumeRight) {
		mediaPlayer.setVolume(volumeLeft, volumeRight);
	}

	public void dispose() {
		if(mediaPlayer.isPlaying()){
			stop();
		}
		mediaPlayer.release();
	}
}